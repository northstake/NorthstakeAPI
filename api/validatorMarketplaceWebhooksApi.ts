/**
 * Northstake
 * Northstake api
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ErrorResponse } from '../model/errorResponse';
import { WebHookLookupAnswer } from '../model/webHookLookupAnswer';
import { WebhookRegistration } from '../model/webhookRegistration';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth, JWTAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.northstake.dk/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ValidatorMarketplaceWebhooksApiApiKeys {
    ApiKeyAuth,
}



export class ValidatorMarketplaceWebhooksApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new JWTAuth('your_api_key', 'your_private_key'),
        'bearerTokenAuth': new HttpBearerAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'x-api-key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ValidatorMarketplaceWebhooksApiApiKeys, value: string) {
        (this.authentications as any)[ValidatorMarketplaceWebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(accessToken: string | (() => string)) {
        this.authentications.bearerTokenAuth.accessToken = accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Delete a registered Validator Marketplace webhook
     * @param webhookId Unique identifier of the registered webhook
     */

   



   public async deleteWebhook (webhookId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ body: any, status: number }> {

        const localVarPath = this.basePath + '/validatorMarketplace/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
       
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};


        // Verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter "webhookId" was null or undefined when calling deleteWebhook.');
        }







        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;



        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
                 return new Promise<{ body: any, status: number }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    console.error('API call error:', error);
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ body: body, status: response.statusCode });
                    } else {
                        console.error('API response error:', response.statusCode);
                        resolve({ body: body, status: response.statusCode });
                    }
                }
            });
        });
    } )
}
    /**
     * 
     * @summary List all registered validator marketplace webhooks for the user
     */

   



   public async listRegisteredWebhooks (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ body: Array<WebHookLookupAnswer>, status: number }> {

        const localVarPath = this.basePath + '/validatorMarketplace/webhooks';
       
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};









        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;



        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
                 return new Promise<{ body: Array<WebHookLookupAnswer>, status: number }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    console.error('API call error:', error);
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        body = ObjectSerializer.deserialize(body, "Array<WebHookLookupAnswer>");
                        resolve({ body: body, status: response.statusCode });
                    } else {
                        console.error('API response error:', response.statusCode);
                        resolve({ body: body, status: response.statusCode });
                    }
                }
            });
        });
    } )
}
    /**
     * Registers a webhook URL for receiving push notifications from Northstake regarding events in the Validator Marketplace. When registered events occur, webhooks are triggered, and JSON payloads are sent as POST requests to the specified URL.  A webhook can subscribe to different event types. Here are descriptions and example payloads for each supported event. These payloads are what will be POST\'ed to your Webhook endpoint.  (For more details regarding webhook payloads, refer to the schemas for the WebhookPayload_XXXX types in documentation)  - `RFQAvailable`: Triggered when a new RFQ document becomes available. The payload includes detailed information about validators, their balances, exit estimates, and other RFQ-specific details.   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQAvailable\",     \"details\": {       \"id\": \"rfq123\",       \"validators\": [         {           \"validator_index\": 1,           \"balance\": 32,           \"exit_estimates\": [             {               \"estimated_exit_time\": \"2025-03-01T12:00:00Z\",               \"estimated_exit_transaction_deadline\": \"2025-03-01T12:00:00Z\",               \"timestamp\": \"2024-03-01T12:00:00Z\"             }           ]         }       ],       \"total_balance\": 32,       \"payment_address\": \"0xabcd\",       \"estimated_exit_transaction_deadline\": \"2025-03-01T12:00:00Z\",       \"estimated_all_validators_exited_at\": \"2025-03-01T12:00:00Z\",       \"unique_escrow_vault\": \"vault123\"     }   }   ```  - `RFQBidReceived`: Triggered when a new bid is received on an RFQ. Includes the latest quote ID and the bid amount.   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQBidReceived\",     \"details\": {       \"quote_id\": \"quote789\",       \"amount\": 5000,       \"timestamp\": \"2024-03-01T13:00:00Z\"     }   }   ```  - `RFQBidAccepted`: Triggered when a bid is accepted. Includes the quote ID and the accepted amount.   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQBidAccepted\",     \"details\": {       \"quote_id\": \"quote789\",       \"amount\": 5000,       \"timestamp\": \"2024-03-02T14:30:00Z\",       \"escrow_address\": \"0x12345\"     }   }   ```  - `RFQEscrowEvent`: Triggered when an escrow payment is made. Includes transaction hash and payment amount.   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQEscrowEvent\",     \"details\": {       \"transaction_hash\": \"0xabc123\",       \"amount\": 5000,       \"timestamp\": \"2024-03-03T15:45:00Z\"     }   }   ```  - `RFQTransferProposalReceived`: Notifies an RFQ seller of a new transfer proposal on their RFQ   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQTransferProposalReceived\",     \"details\": {       \"transaction_hash\": \"0xabc123\",       \"timestamp\": \"2024-03-03T15:45:00Z\",       \"proposal_id\": \"0x12345\"\"     }   }   ```  - `RFQValidatorWithdrawalChange`: Triggered when a validator withdrawal status changes. Includes transaction hash and validator index.   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQValidatorWithdrawalChange\",     \"details\": [{       \"transaction_hash\": \"0xdef456\",       \"validator_index\": 1,       \"timestamp\": \"2024-03-04T16:50:00Z\"     },     {       \"transaction_hash\": \"0xdef457\",       \"validator_index\": 2,       \"timestamp\": \"2024-03-04T16:50:00Z\"     },                 {       \"transaction_hash\": \"0xdef458\",       \"validator_index\": 3,       \"timestamp\": \"2024-03-04T16:50:00Z\"     },     ]   }   ```  - `RFQEscrowReleased`: Triggered when escrow funds are released. Includes transaction hash and the released amount.   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQEscrowReleased\",     \"details\": {       \"transaction_hash\": \"0xghi789\",       \"amount\": 5000,       \"timestamp\": \"2024-03-05T17:55:00Z\"     }   }   ```  - `RFQValidatorExited `: Notifies the owner whenever a validator exits the ethereum network   ```json   {     \"document_id\": \"rfq123\",     \"event\": \"RFQValidatorExited\",     \"details\": {       \"validator_index\": \"0xghi789\",       \"timestamp\": \"2024-03-05T17:55:00Z\"     }   }   ```  **Webhook Security Note:** All webhook requests include a `Bearer` token in the `Authorization` header. Recipients must validate this token to ensure the notifications are from a trusted source. 
     * @summary Register a webhook to track Northstake validator marketplace events
     * @param webhookRegistration 
     */

   



   public async registerWebhook (webhookRegistration: WebhookRegistration, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ body: any, status: number }> {

        const localVarPath = this.basePath + '/validatorMarketplace/webhooks';
       
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};


        // Verify required parameter 'webhookRegistration' is not null or undefined
        if (webhookRegistration === null || webhookRegistration === undefined) {
            throw new Error('Required parameter "webhookRegistration" was null or undefined when calling registerWebhook.');
        }







        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;



        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookRegistration, "WebhookRegistration")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
                 return new Promise<{ body: any, status: number }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    console.error('API call error:', error);
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ body: body, status: response.statusCode });
                    } else {
                        console.error('API response error:', response.statusCode);
                        resolve({ body: body, status: response.statusCode });
                    }
                }
            });
        });
    } )
}
}
